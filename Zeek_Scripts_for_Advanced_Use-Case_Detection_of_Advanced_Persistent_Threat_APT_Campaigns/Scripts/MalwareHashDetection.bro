@load base/frameworks/notice
@load base/frameworks/input
@load ./IoC_TTP

redef enum Notice::Type += 
{
    FilesBlacklist
};

type MalID: record {
    id: count;
};

type MalHashes: record {
	group_name: string;
	intel_path: string;
	log_path: string;
};

type hash: record {
    malware: string;
};

global Hash_filter: table[count] of MalHashes = table();
global malwarehashes: table[count] of set[string] = table();
global hashx = 1;

#This event will get Malware Hash against each APT Group
event hashentry(description: Input::TableDescription,
                     t: Input::Event, data: MalID, data1: MalHashes) {
        malwarehashes[hashx] = set();
        Input::add_table([$source=Hash_filter[hashx]$intel_path, $name=Hash_filter[hashx]$intel_path,
                            $idx=hash, $destination=malwarehashes[hashx]]);
        Input::remove(Hash_filter[hashx]$intel_path);
        ++hashx;
}

event bro_init()
{
    Input::add_table([$source="/nsm/bro/share/bro/policy/fyp/Zeek_Scripts_for_Advanced_Use-Case_Detection_of_Advanced_Persistent_Threat_APT_Campaigns/Scripts/MalwareHashSources.txt", $name="MalwareHashSources",
                          $idx=MalID,$val=MalHashes, $destination=Hash_filter, $ev=hashentry]);
    Input::remove("MalwareHashSources");
}


# The Files event will call on every file entering our system to check malware hash.
event Files::log_files(rec: Files::Info)
{
	local i = 1;
    for (f in malwarehashes)
    {
		for (req in malwarehashes[i])
		{
			if (rec?$sha256)
			{
				# if (rec?$overflow_bytes)
				# {
				# 	if (rec$overflow_bytes > 0)
				# 	{
				# 		Files::enable_reassembly(Files::fa_file);
				# 	}
				# }
				if (rec$sha256 == req)
				{
					local format: string = "%F, %H:%M:%S";
					# NOTICE([
					# 		$note=FilesBlacklist,
					# 		$ts=rec$ts,
					# 		$msg=fmt("%s file has entered the system while blacklisted", rec$sha256),
					# 		$identifier=cat(rec$ts)
					# ]);
					local source_ip: addr = 0.0.0.0;
					local dest_ip: addr = 0.0.0.0;
					if (rec?$tx_hosts)
					{
						for (ip in rec$tx_hosts)
							source_ip = ip;
					}
					if (rec?$rx_hosts)
					{
						for (ip in rec$rx_hosts)
							dest_ip = ip;
					}

					IoCToTTP::IoC_TTP_Mapping(strftime(format,rec$ts), Hash_filter[i]$group_name,"Malware Hash",rec$sha256, source_ip, dest_ip, Hash_filter[i]$log_path);
				}
			}
		}
		++i;
    }
}

#File Gap event will call if file has overflow bytes.
event file_gap(f: fa_file, offset: count, skipped: count)
{
	 Files::enable_reassembly(f);
}